#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "../../Shaders/Includes/Inputs/CameraParams.hlsl"
#include "../../Shaders/Includes/Transform.hlsl"

#pragma kernel Main
#define LINEAR_DEPTH(rawDepth) ((unity_OrthoParams.w == 0)?LinearEyeDepth(rawDepth, _ZBufferParams):lerp(_ProjectionParams.y,_ProjectionParams.z,rawDepth))
Texture2D<float> _DepthBuffer;
Texture2D<float4> _NormalBuffer;
RWTexture2D<float4> _ConnectivityMap;
int _Width;
int _Height;
float _Threshold;
uint _SamplingScale;

void CheckConnected(int2 center, int2 target, inout uint connected, inout uint closer)
{
    if(target.x >= _Width || target.y >= _Height || target.x < 0 || target.y < 0)
    {
        connected = 1;
        closer = 1;
        return;
    }

    float centerDepth = _DepthBuffer[center];
    float targetDepth = _DepthBuffer[target];

    #if defined(UNITY_REVERSED_Z)
    centerDepth = 1.0 - centerDepth;
    targetDepth = 1.0 - targetDepth;
    #endif

    centerDepth = LINEAR_DEPTH(centerDepth);
    targetDepth = LINEAR_DEPTH(targetDepth);

    closer = centerDepth < targetDepth ? 1 : 0;
    connected = 1;

    float2 centerUV = float2(float(center.x) / float(_Width), float(center.y) / float(_Height));
    float3 centerPos = GetViewPositionWithDepth(centerUV, _DepthBuffer[center]);

    float2 targetUV = float2(float(target.x) / float(_Width), float(target.y) / float(_Height));
    float3 targetPos = GetViewPositionWithDepth(targetUV, _DepthBuffer[target]);

    float3 normalCenter = _NormalBuffer[center].xyz;
    normalCenter = TransformWorldToViewDir(normalCenter);

    float2 pixelSpacing = (centerPos.xy - targetPos.xy);
    float dz_x = -normalCenter.x * pixelSpacing.x / normalCenter.z;
    float dz_y = -normalCenter.y * pixelSpacing.y / normalCenter.z;

    float predictDepth = centerDepth + dz_x + dz_y;

    float resultCenter = abs(predictDepth - targetDepth);

    float3 normalTarget = _NormalBuffer[target].xyz;
    normalTarget = TransformWorldToViewDir(normalTarget);

    dz_x = -normalTarget.x * pixelSpacing.x / normalTarget.z;
    dz_y = -normalTarget.y * pixelSpacing.y / normalTarget.z;

    predictDepth = centerDepth + dz_x + dz_y;

    float resultTarget = abs(predictDepth - targetDepth);

    if(dot(normalTarget, normalTarget) < 0.5 && dot(normalCenter, normalCenter) >= 0.5) connected = 0;
    else if(dot(normalTarget, normalTarget) >= 0.5 && dot(normalCenter, normalCenter) < 0.5) connected = 0;
    else if(resultCenter > _Threshold && resultTarget > _Threshold) connected = 0;
}

[numthreads(8,8,1)]
void Main (uint3 id : SV_DispatchThreadID)
{
    if(id.x > uint(_Width) || id.y > uint(_Height)) return;

    int2 sourceCoord = int2(id.xy);
    float4 result = float4(0.0, 0.0, 0.0, 0.0);
    float3 debug = float3(0.0, 0.0, 0.0);

    uint connected = 0;
    uint closer = 0;
    uint center = ((id.x % _SamplingScale) == (_SamplingScale / 2) && (id.y % _SamplingScale) == (_SamplingScale / 2)) ? 1 : 0;

    CheckConnected(sourceCoord, sourceCoord + int2(1, 0), connected, closer);
    result.x = PackFloatInt8bit(0.0, (connected << 7) + (closer << 6) + (center << 5), 256.0);

    CheckConnected(sourceCoord, sourceCoord + int2(0, 1), connected, closer);
    result.y = PackFloatInt8bit(0.0, (connected << 7) + (closer << 6) + (center << 5), 256.0);

    CheckConnected(sourceCoord, sourceCoord - int2(1, 0), connected, closer);
    result.z = PackFloatInt8bit(0.0, (connected << 7) + (closer << 6) + (center << 5), 256.0);

    CheckConnected(sourceCoord, sourceCoord - int2(0, 1), connected, closer);
    result.w = PackFloatInt8bit(0.0, (connected << 7) + (closer << 6) + (center << 5), 256.0);


    _ConnectivityMap[id.xy] = result;
}